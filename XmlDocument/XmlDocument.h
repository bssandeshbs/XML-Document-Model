#ifndef XMLDOCUMENT_H
#define XMLDOCUMENT_H
////////////////////////////////////////////////////////////////////////////////////////
//  XmlDocument.h - Container of XML Element Nodes								      //
//  ver 1.3																			  //
//  Language:      Visual C++ 2013, Update 2										  //
//  Platform:      ASUS TP300L, Windows 8.1											  //
//  Application:   XML Document Model Project										  //
//  Author:        Sandesh Bellur Shashidhara, Syracuse University					  //
//                 (315) 751-4826, sbellurs@syr.edu									  //
//	Original Intial Author:      Jim Fawcett, jfawcett@twcny.rr.com	                  //
//              																      //
////////////////////////////////////////////////////////////////////////////////////////
/*
* Package Operations:
* -------------------
* This package was developed Initial by Jim Fawcett as a Helper for  XML Document Model.
* It uses C++11 constructs,most noteably std::shared_ptr.  The XML Document Model is essentially
* a program-friendly wrapper around an Abstract Syntax Tree (AST) used to
* contain the results of parsing XML markup.
*
* Abstract Syntax Trees, defined in this package, are unordered trees with
* two types of nodes:
*   Terminal nodes     - nodes with no children
*   Non-Terminal nodes - nodes which may have a finite number of children
* They are often used to contain the results of parsing some language.
*
* The elements defined in the companion package, XmlElement, will be used in
* the AST defined in this package.  They are:
*   AbstractXmlElement - base for all the XML Element types
*   DocElement         - XML element with children designed to hold prologue, Xml root, and epilogue
*   TaggedElement      - XML element with tag, attributes, child elements
*   TextElement        - XML element with only text, no markup
*   CommentElement     - XML element with comment markup and text
*   ProcInstrElement   - XML element with markup and attributes but no children
*   XmlDeclarElement   - XML declaration element with attributes
*
* This package provides the required functions to build the AST tree programitically
*
* Required Files:
* ---------------
*   - XmlDocument.h, XmlDocument.cpp,
*     XmlElement.h, XmlElement.cpp, ProcessFile.h, ProcessFile.cpp
*
* Build Process:
* --------------
*   devenv XmlDocument.sln /debug rebuild
*
* Public Interface:
* =================
* constructor () :  XmlDocument(const std::string& src, const std::string& filename = "string")
*			Input : Source Type - File or String and filename
* void buildTree() : the core function which reads each token generated by parser and builds the tree
* void elementByAttr(); - Find Element by attribute Id and Value
*		    Output - Returns the shared pointer of the element found
* XmlDocument& elements(const std::string& tag);  - Find Element by tag, found_ vector contains the result
* XmlDocument& children(const std::string& tag = ""); - Find children for a tag, found_[0] contains parent
* element
* XmlDocument& descendents(const std::string& tag = ""); - Find Descendents for an element
* std::vector<sPtr> select(); - Performs move of found_
*		    Output - returns the result vector
* bool addChild(const std::string& parentTag, const std::string& childTag) - Add a child to parent
*		    Output - returns the results of addChild operation
* std::vector<std::pair<std::string, std::string>> getAttributes() - get all attributes for a element
*		    Output - vector of attribute name and value
* bool removeChild(const std::string& parentTag, const std::string& tag); - removes a child from element
*		    Output - returns the results of remove operation
* bool addAttribute(const std::string& parentTag, const std::string& attributeName,
* const std::string& attributeValue); - Add a new attribute to a element
*			Output - Returns whether the attribute was added successfully
* bool removeAttribute(const std::string& parentTag, const std::string& attributeName);
*           Output - Removes a attibute from an element
* std::string getDocumentString();
*		    Output - Returns the toString() of the pDocument
* bool generateRootElement(const std::string& parentTag); - Generate a root element for a empty document
*		    Output - Returns the result of addRoot operation
* std::vector<std::string> processFile(const std::string& fileName, const std::string& src);
*		    Output - Returns a vector of tokens generated by tokensizer
* void elementByAttr(); - Find Element by attribute Id and Value
*		    Output - Returns the shared pointer of the element found
* Usage :
* ==================
* XmlDocument document(src, fileName);
* document.buildTree();
* document.elementByAttr(attributeName);
* document.elements(tag).sele.ct();
* document.elements(elementTag).children().select();
* document.elements(elementTag).descendents(childTag).select();
* document.select();
* document.addChild(parentTag,childTag)
* document.elements(elementTag1).getAttributes();
* document.removeChild(parentTag,childTag)
* document.addAttribute(parentTag,attributeName,value);
* document.getDocumentString();
* document.generateRootElement(parentTag);
* document.processFile(fileName,src);
*
* Maintenance History:
* --------------------
*  ver 1.3 : 10 Mar 15
*  provided Implementation of new methods to construct tree
* ver 1.2 : 21 Feb 15
* - modified these comments
* ver 1.1 : 14 Feb 15
* - minor changes to comments, method arguments
* Ver 1.0 : 11 Feb 15
* - first release
*
*/
#include <memory>
#include <string>
#include "../XmlElement/XmlElement.h"
#include <vector>
#include <cctype>
#include <iostream>
#include <stack>
#include <algorithm>
#include "ProcessFile.h"

namespace XmlProcessing
{
	class XmlDocument
	{
	public:
		using sPtr = std::shared_ptr < AbstractXmlElement > ;
		XmlDocument(const std::string& src, const std::string& filename = "string");
		XmlDocument();
		XmlDocument(XmlDocument&& s);
		XmlDocument& operator=(XmlDocument&& s);
		void buildTree();
		std::shared_ptr < AbstractXmlElement > elementByAttr(const std::string& id);
		XmlDocument& elements(const std::string& tag);
		XmlDocument& children(const std::string& tag = "");
		XmlDocument& descendents(const std::string& tag = "");
		std::vector<sPtr> select();
		bool addChild(const std::string& parentTag, const std::string& childTag);
		std::vector<std::pair<std::string, std::string>> getAttributes();
		bool XmlProcessing::XmlDocument::removeChild(const std::string& parentTag, const std::string& tag);
		bool addAttribute(const std::string& parentTag, const std::string& attributeName, const std::string& attributeValue);
		bool removeAttribute(const std::string& parentTag, const std::string& attributeName);
		std::string getDocumentString();
		bool generateRootElement(const std::string& parentTag);
		std::vector<std::string> XmlDocument::processFile(const std::string& fileName, const std::string& src);
	private:
		void buildTaggedRoot(std::string token);
		void findElement(std::shared_ptr<AbstractXmlElement> sptr, const std::string& tag);
		void findDescendents(std::shared_ptr<AbstractXmlElement> sptr, const std::string& tag);
		std::vector<std::string> split(const std::string &str, const char &delim);
		std::shared_ptr < AbstractXmlElement > determineType(std::vector<std::string> token);
		std::shared_ptr<AbstractXmlElement> findAttr(std::shared_ptr<AbstractXmlElement> sptr, const std::string& id);
		void addAttribute(std::vector<std::string> res, std::shared_ptr < AbstractXmlElement > sp1);
		std::string addComment(std::vector<std::string> res);
		bool rootStarted = false;
		sPtr pDocElement_;         // AST that holds procInstr, comments, XML root, and more comments
		std::vector<sPtr> found_;
		std::stack <sPtr> taggedElementstack;
		std::string rootTagNode;
		std::vector<std::string> tokens;
		ProcessFile processFl;
	};
}

#endif
